# 一、JavaScript基础

## 变量和类型

### 1. JavaScript规定了几种语言类型

JavaScript规定了七种语言类型，他们是：

```
String、Number、Object
Boolean、Symbol
Undefined、Null
```

### 2. JavaScript对象的底层数据结构是什么

可以简单粗暴理解为是一个 传统的字典模式/哈希表。

参考 [V8 Object 内存结构与属性访问详解](https://segmentfault.com/a/1190000008188648)

### 3. Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol

Symbol 值通过Symbol函数生成。这就是说，对象的属性名可以有两种类型：一种是字符串，另一种是Symbol类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。


属性名独一无二，不会冲突，可以作为属性的key。

symbol类型的 key 不能被 Object.keys 和 for..of 循环枚举。因此可当作私有变量使用。

```jsx
let mySymbol = Symbol('key');
// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';
// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};
```

### 4. JavaScript中的变量在内存中的具体存储形式

基本类型: 保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问

引用类型: 保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。

### 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作

装箱：就是把基本类型转变为对应的对象。装箱分为隐式和显示

```jsx
// 隐式装箱： 每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。
// 在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。
// 这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。
let num=123;
num.toFixed(2); // '123.00'//上方代码在后台的真正步骤为
var c = new Number(123);
c.toFixed(2);
c = null;
// 显式装箱: 通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。
var obj = new String('123');
```

拆箱: 拆箱与装箱相反，把对象转变为基本类型的值。

```jsx
Number([1]); //1
// 转换演变：
[1].valueOf(); // [1];
[1].toString(); // '1';Number('1'); //1
```

### 6. 理解值类型和引用类型

（1）值类型（基本类型）：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol http://es6.ruanyifeng.com/# docs/symbol )

（2）引用类型：对象（Object）、数组（Array）、函数（Function）

（1）值类型：
    1. 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）

    2. 保存与复制的是值本身

    3. 使用typeof检测数据的类型

    4. 基本类型数据是值类型

（2）引用类型：
    1. 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）

    2. 保存与复制的是指向对象的一个指针

    3. 使用instanceof检测数据类型

    4. 使用new()方法构造出的对象是引用型

### 7.null和undefined的区别

null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。

undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。

参考： [undefined与null的区别 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)

### 8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

#### 判断JavaScript数据类型的方式：

1. typeof:

对于基本类型,除null以外,均可以返回正确的结果;
对于引用类型,除function以外,一律返object类型;
对于null,返回object类型;
对于function返回function类型

2. instanceof

只能用来判断两个对象是否属于实例关系,而不能判断一个对象实例具体属于哪种类型.

3. constructor：查看对象对应的构造函数

* null和undefined是无效的对象,因此是不会有constructor存在的,这两种类型的数据需要通过其他方式来判断;

* 函数的constructor是不稳定的,这个主要体现在自定义对象上,当开发者重写 prototype后,原有的constructor引用会丢失,constructor会默认为Object

备注：使用Object.create()创建的js对象，没有constructor

4. Object.prototype.toString(可以说不管是什么类型，它都可以立即判断出)

toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型。
toString 对于Object对象,直接调用toString()就能返回[object Object];而对于其他对象,则需要通过call/apply来调用才能返回正确的类型信息。

准确的判断数组类型: Array.isArray()


### 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用

#### 可能发生隐式类型转换的场景以及转换原则：

+：+ 号操作时，数字被隐式转换成字符串，实际上做的是字符串连接操作。做除了加法以外的运算操作时，字符串被隐式转换成数字，实际上做的是数值计算。

. 点:数字、字符串等基本类型在调用方法时，隐式地将类型转换成对象。

if：If()括号里的表达式部分会被隐式转化为布尔类型进行判别。

==：等号左右两边会被转化为同一种类型再进行比较


#### 如何避免或巧妙应用

把字符串类型转换为数字
```jsx
let i = '1' 
console.log(typeof(+i))
```

### 10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法

#### 出现小数精度丢失的原因

0.1 + 0.2 != 0.3 // true

JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。计算机的二进制实现和位数限制有些数无法有限表示。

#### JavaScript可以存储的最大数字、最大安全数字

能够表示的最大数字 Number.MAX_VALUE 等于 1.7976931348623157e+308 ,最大安全数字 Number.MAX_SAFE_INTEGER 等于 9007199254740991

#### JavaScript处理大数字的方法、避免精度丢失的方法

解决方案：

* 计算小数时，先乘 100 或 1000，变成整数再运算

* 如果值超出了安全整数，有一个最新提案，BigInt 大整数，它可以表示任意大小的整数，注意只能表示整数，而不受安全整数的限制

* 使用计算库进行数据处理